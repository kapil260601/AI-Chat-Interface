// // This is a mock WebSocket service to simulate streaming responses

// import { v4 as uuidv4 } from 'uuid';
// import type { Message } from '../types';

// type WebSocketCallback = (message: string) => void;
// type WebSocketErrorCallback = (error: Error) => void;
// type WebSocketCloseCallback = () => void;

// class MockWebSocket {
//   private callbacks: {
//     message: WebSocketCallback[];
//     error: WebSocketErrorCallback[];
//     close: WebSocketCloseCallback[];
//   };
//   private isConnected: boolean;
//   private isStreaming: boolean;
//   private streamInterval: number | null;
//   private streamTimeout: number | null;

//   constructor() {
//     this.callbacks = {
//       message: [],
//       error: [],
//       close: [],
//     };
//     this.isConnected = false;
//     this.isStreaming = false;
//     this.streamInterval = null;
//     this.streamTimeout = null;
//   }

//   connect(): Promise<void> {
//     return new Promise((resolve) => {
//       // Simulate connection delay
//       setTimeout(() => {
//         this.isConnected = true;
//         resolve();
//       }, 500);
//     });
//   }

//   onMessage(callback: WebSocketCallback) {
//     this.callbacks.message.push(callback);
//     return this;
//   }

//   onError(callback: WebSocketErrorCallback) {
//     this.callbacks.error.push(callback);
//     return this;
//   }

//   onClose(callback: WebSocketCloseCallback) {
//     this.callbacks.close.push(callback);
//     return this;
//   }

//   close() {
//     this.isConnected = false;
//     this.stopStreaming();
//     this.callbacks.close.forEach(callback => callback());
//   }

//   // Send a message to the mock server and get a streaming response
//   sendMessage(message: string, agentId?: string | null): { messageId: string } {
//     if (!this.isConnected) {
//       const error = new Error('WebSocket is not connected');
//       this.callbacks.error.forEach(callback => callback(error));
//       throw error;
//     }

//     // Stop any existing streaming
//     this.stopStreaming();

//     // Generate a response based on the input
//     const responseMessageId = uuidv4();
//     this.streamResponse(message, responseMessageId, agentId);

//     return { messageId: responseMessageId };
//   }

//   private streamResponse(userMessage: string, messageId: string, agentId?: string | null) {
//     this.isStreaming = true;

//     // Mock responses based on input
//     let response: string;
    
//     if (userMessage.toLowerCase().includes('hello') || userMessage.toLowerCase().includes('hi')) {
//       response = "Hello! I'm your AI assistant. How can I help you today?";
//     } else if (userMessage.toLowerCase().includes('help')) {
//       response = "I'm here to help! You can ask me questions, request information, or just chat. What would you like to know?";
//     } else if (userMessage.toLowerCase().includes('code') || userMessage.toLowerCase().includes('javascript')) {
//       response = "Here's a simple JavaScript function:\n\n```javascript\nfunction greet(name) {\n  return `Hello, ${name}!`;\n}\n\nconsole.log(greet('World'));\n```\n\nThis function takes a name parameter and returns a greeting message.";
//     } else if (userMessage.toLowerCase().includes('chart') || userMessage.toLowerCase().includes('graph')) {
//       response = "I can describe how to create charts with libraries like Chart.js or D3.js. Would you like me to provide a code example for creating a basic chart?";
//     } else if (userMessage.toLowerCase().includes('market') || userMessage.toLowerCase().includes('stock')) {
//       response = "As a trading assistant, I can analyze market trends and provide insights on stocks. However, I don't have real-time market data in this demo. In a real implementation, I could connect to financial APIs to provide up-to-date information.";
//     } else {
//       response = "I understand you're asking about \"" + userMessage.substring(0, 30) + (userMessage.length > 30 ? "..." : "") + "\". While I don't have specific information on this topic in this demo, in a fully implemented version I would be able to provide detailed insights and analysis based on your query.";
//     }

//     // Add some agent-specific flavor if an agent is selected
//     if (agentId) {
//       response += "\n\n(Response generated by a custom agent)";
//     }

//     // Stream the response token by token (simulated)
//     let currentIndex = 0;
//     const tokens = response.split(/(?<=\s|[.,!?;:])/g); // Split by spaces and punctuation
    
//     this.streamInterval = window.setInterval(() => {
//       if (currentIndex < tokens.length && this.isStreaming) {
//         const token = tokens[currentIndex];
//         this.callbacks.message.forEach(callback => callback(token));
//         currentIndex++;
//       } else {
//         this.stopStreaming();
//       }
//     }, 50); // Adjust speed as needed
//   }

//   stopStreaming() {
//     this.isStreaming = false;
//     if (this.streamInterval !== null) {
//       clearInterval(this.streamInterval);
//       this.streamInterval = null;
//     }
//     if (this.streamTimeout !== null) {
//       clearTimeout(this.streamTimeout);
//       this.streamTimeout = null;
//     }
//   }

//   isActive(): boolean {
//     return this.isConnected && this.isStreaming;
//   }
// }

// // Singleton instance
// const mockWebSocket = new MockWebSocket();

// export default mockWebSocket;

// This is a mock WebSocket service to simulate streaming responses

import { v4 as uuidv4 } from 'uuid';
import type { Message } from '../types';

type WebSocketCallback = (message: string, messageId: string) => void;
type WebSocketErrorCallback = (error: Error) => void;
type WebSocketCloseCallback = () => void;

class MockWebSocket {
  private callbacks: {
    message: WebSocketCallback[];
    error: WebSocketErrorCallback[];
    close: WebSocketCloseCallback[];
  };
  private isConnected: boolean;
  private isStreaming: boolean;
  private streamInterval: number | null;
  private streamTimeout: number | null;
  private currentMessageId: string | null;

  constructor() {
    this.callbacks = {
      message: [],
      error: [],
      close: [],
    };
    this.isConnected = false;
    this.isStreaming = false;
    this.streamInterval = null;
    this.streamTimeout = null;
    this.currentMessageId = null;
  }

  connect(): Promise<void> {
    return new Promise((resolve) => {
      // Simulate connection delay
      setTimeout(() => {
        this.isConnected = true;
        resolve();
      }, 500);
    });
  }

  onMessage(callback: WebSocketCallback) {
    this.callbacks.message.push(callback);
    return this;
  }

  onError(callback: WebSocketErrorCallback) {
    this.callbacks.error.push(callback);
    return this;
  }

  onClose(callback: WebSocketCloseCallback) {
    this.callbacks.close.push(callback);
    return this;
  }

  close() {
    this.isConnected = false;
    this.stopStreaming();
    this.callbacks.close.forEach(callback => callback());
  }

  // Send a message to the mock server and get a streaming response
  sendMessage(message: string, agentId?: string | null): { messageId: string } {
    if (!this.isConnected) {
      const error = new Error('WebSocket is not connected');
      this.callbacks.error.forEach(callback => callback(error));
      throw error;
    }

    // Stop any existing streaming
    this.stopStreaming();

    // Generate a response based on the input
    const responseMessageId = uuidv4();
    this.currentMessageId = responseMessageId;
    this.streamResponse(message, responseMessageId, agentId);

    return { messageId: responseMessageId };
  }

  private streamResponse(userMessage: string, messageId: string, agentId?: string | null) {
    this.isStreaming = true;

    // Mock responses based on input
    let response: string;
    
    if (userMessage.toLowerCase().includes('hello') || userMessage.toLowerCase().includes('hi')) {
      response = "Hello! I'm your AI assistant. How can I help you today?";
    } else if (userMessage.toLowerCase().includes('help')) {
      response = "I'm here to help! You can ask me questions, request information, or just chat. What would you like to know?";
    } else if (userMessage.toLowerCase().includes('code') || userMessage.toLowerCase().includes('javascript')) {
      response = "Here's a simple JavaScript function:\n\n```javascript\nfunction greet(name) {\n  return `Hello, ${name}!`;\n}\n\nconsole.log(greet('World'));\n```\n\nThis function takes a name parameter and returns a greeting message.";
    } else if (userMessage.toLowerCase().includes('chart') || userMessage.toLowerCase().includes('graph')) {
      response = "I can describe how to create charts with libraries like Chart.js or D3.js. Would you like me to provide a code example for creating a basic chart?";
    } else if (userMessage.toLowerCase().includes('market') || userMessage.toLowerCase().includes('stock')) {
      response = "As a trading assistant, I can analyze market trends and provide insights on stocks. However, I don't have real-time market data in this demo. In a real implementation, I could connect to financial APIs to provide up-to-date information.";
    } else {
      response = "I understand you're asking about \"" + userMessage.substring(0, 30) + (userMessage.length > 30 ? "..." : "") + "\". While I don't have specific information on this topic in this demo, in a fully implemented version I would be able to provide detailed insights and analysis based on your query.";
    }

    // Add some agent-specific flavor if an agent is selected
    if (agentId) {
      response += "\n\n(Response generated by a custom agent)";
    }

    // Stream the response token by token (simulated)
    let currentIndex = 0;
    const tokens = response.split(/(?<=\s|[.,!?;:])/g); // Split by spaces and punctuation
    
    this.streamInterval = window.setInterval(() => {
      if (currentIndex < tokens.length && this.isStreaming && messageId === this.currentMessageId) {
        const token = tokens[currentIndex];
        this.callbacks.message.forEach(callback => callback(token, messageId));
        currentIndex++;
      } else {
        this.stopStreaming();
      }
    }, 50); // Adjust speed as needed
  }

  stopStreaming() {
    this.isStreaming = false;
    this.currentMessageId = null;
    if (this.streamInterval !== null) {
      clearInterval(this.streamInterval);
      this.streamInterval = null;
    }
    if (this.streamTimeout !== null) {
      clearTimeout(this.streamTimeout);
      this.streamTimeout = null;
    }
  }

  isActive(): boolean {
    return this.isConnected && this.isStreaming;
  }
}

// Singleton instance
const mockWebSocket = new MockWebSocket();

export default mockWebSocket;